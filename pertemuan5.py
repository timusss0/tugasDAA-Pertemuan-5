# -*- coding: utf-8 -*-
"""Pertemuan5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1unCs1ahGGrCLiAqleZSvuC-NP_Dqqwws
"""



def maxCrossingSum(arr, i, m, h):
    sm = 0
    left_sum = -10000

    # Mencari sum maksimum di bagian kiri dari m
    for j in range(m, i-1, -1):
        sm = sm + arr[j]
        if sm > left_sum:
            left_sum = sm

    sm = 0
    right_sm = -10000

    # Mencari sum maksimum di bagian kanan dari m+1
    for j in range(m+1, h+1):
        sm = sm + arr[j]
        if sm > right_sm:
            right_sm = sm

    # Mengembalikan nilai maksimal yang mencakup elemen tengah
    return max(left_sum + right_sm, left_sum, right_sm)

def maxSubArraySum(arr, i, h):
    # Jika hanya ada satu elemen
    if i == h:
        return arr[i]
    # Hitung titik tengah
    m = (i + h) // 2

    # Cari subarray maksimal di bagian kiri, kanan, dan melintasi bagian tengah
    return max(maxSubArraySum(arr, i, m),
               maxSubArraySum(arr, m + 1, h),
               maxCrossingSum(arr, i, m, h))

arr = [4, 12, 23, 9, 21, 1, 35, 2, 24]
n = len(arr)

max_sum = maxSubArraySum(arr, 0, n-1)
print("Maximum contiguous sum is", max_sum)

def divideAndConquer_Max(arr, ind, length):
    # Inisialisasi maximum
    maximum = -1

    # Kondisi dasar: ketika kita sampai di elemen terakhir atau kedua terakhir
    if ind >= length - 2:
        if arr[ind] > arr[ind + 1]:
            return arr[ind]
        else:
            return arr[ind + 1]

    # Rekursi untuk mencari nilai maksimum di elemen berikutnya
    maximum = divideAndConquer_Max(arr, ind + 1, length)

    # Bandingkan dengan elemen saat ini
    if arr[ind] > maximum:
        return arr[ind]
    else:
        return maximum

def divideAndConquer_Min(arr, ind, length):
    # Inisialisasi minimum
    minimum = arr[ind]

    # Kondisi dasar: ketika kita sampai di elemen terakhir atau kedua terakhir
    if ind >= length - 2:
        if arr[ind] < arr[ind + 1]:
            return arr[ind]
        else:
            return arr[ind + 1]

    # Rekursi untuk mencari nilai minimum di elemen berikutnya
    minimum = divideAndConquer_Min(arr, ind + 1, length)

    # Bandingkan dengan elemen saat ini
    if arr[ind] < minimum:
        return arr[ind]
    else:
        return minimum

# Array contoh
arr = [6, 4, 8, 90, 12, 56, 7, 1, 63]

# Cari maksimum dan minimum
maximum = divideAndConquer_Max(arr, 0, len(arr))
minimum = divideAndConquer_Min(arr, 0, len(arr))

print("The minimum number in the array is : ", minimum)
print("The maximum number in the array is : ", maximum)

"""INI ADALAH MERGE SORT"""

def mergeSort(array):
  if len(array) > 1:

    r = len(array) //2
    L = array[:r]
    M = array[r:]

    mergeSort(L)
    mergeSort(M)

    i = j = k = 0

    while i < len(L) and j < len(M):
      if L[i] < M[j]:
       array[k] = L[i]
       i += 1
      else:
        array[k] = M[j]
        j += 1
      k += 1

      while i < len(L):
        array[k] = L[i]
        i += 1
        k += 1
      while j < len(M):
        array[k] = M[j]
        j += 1
        k += 1

def printList(array):
  for i in range(len(array)):
    print(array[i], end="")
  print()

array = [8,3,2,9,7,1,5,3]

mergeSort(array)

print("Sorted array is: ")
printList(array)

"""INSERT SORT

"""

def insertion_sort(arr):
  for i in range(1 , len(arr)):
      key = arr[i]
      j = i - 1
      while j >= 0 and key < arr[j]:
              arr[j + 1] = arr[j]
              j -= 1
      arr[j + 1] = key
  return arr

arr = [4,12,23,9,21,1,5,2]
print("sorted array is : ", insertion_sort(arr))

"""Quick Sort"""

def partition(array, low, high):
  pivot = array[high]

  i = low - 1
  for j in range(low, high):
    if array[j] <= pivot:
      i = i + 1
      (array[i], array[j]) = (array[j], array[i])
  (array[i + 1], array[high]) = (array[high], array[i + 1])
  return i + 1

def quickSort(array, low, high):
  if low < high:
    pi = partition(array, low , high)
    quickSort(array , low ,pi - 1)
    quickSort(array, pi + 1 , high)

data = [1,7,4,1,10,9,-2]
print("Unsorted Array")
print(data)

size = len(data)

quickSort(data, 0 , size -1)

print('soerted array in ascending order : ')
print(data)

def countInversion(arr):
  result = 0
  for i in range(len(arr)):
    for j in range(i+1,len(arr)):
      if arr[i]>arr[j]:
        result+=1
  return result

arr = [21,70,36,14,25]

result = countInversion(arr)
print(result)

# Tanpa divide dan conquer
def maxSubSum(arr):
    max_so_far = 0
    max_ending_here = 0

    for i in range(len(arr)):
        max_ending_here += arr[i]

        if max_ending_here > max_so_far:
            max_so_far = max_ending_here

        if max_ending_here < 0:
            max_ending_here = 0

    return max_so_far

# Example usage
arr = [-2, -5, 6, -2, -3, 1, 5, -6]
result = maxSubSum(arr)
print(result)

def maxCrossingSum(arr, low, mid, high):
    result = 0; leftSum = float('-infinity')
    for i in range(mid, low - 1, -1):
        result += arr[i]
        if result > leftSum:
            leftSum = result

    result = 0; rightSum = float('-infinity')
    for i in range(mid + 1, high + 1):
        result += arr[i]
        if result > rightSum:
            rightSum = result

    return leftSum + rightSum

def maxSum(arr, low, high):
    if low == high:
        return arr[low]

    mid = (low + high) // 2
    return max(maxSum(arr, low, mid),
               maxSum(arr, mid + 1, high),
               maxCrossingSum(arr, low, mid, high))

# Example usage
arr = [-2, -5, 6, -2, -3, 1, 5, -6]
result = maxSum(arr, 0, len(arr) - 1)
print(result)

def longestCommonPrefix(a):
    size = len(a)

    # If size is 0, return an empty string
    if size == 0:
        return ""

    # If size is 1, return the only string
    if size == 1:
        return a[0]

    # Sort the array of strings
    a.sort()

    # Find the minimum length from the first and last string
    end = min(len(a[0]), len(a[size - 1]))

    # Find the common prefix between the first and last string
    i = 0
    while i < end and a[0][i] == a[size - 1][i]:
        i += 1

    pre = a[0][0: i]
    return pre

# Example usage
arr = ["geeksforgeeks", "geeks", "geek", "geezer"]
result = longestCommonPrefix(arr)
print(result)

arr = ["apple", "ape", "april"]
result = longestCommonPrefix(arr)
print(result)

def Solution(arr):
    n = len(arr)
    # If length of array is even
    if n % 2 == 0:
        z = n // 2
        e = arr[z]
        q = arr[z - 1]
        ans = (e + q) / 2
        return ans
    # If length of array is odd
    else:
        z = n // 2
        ans = arr[z]
        return ans

arr1 = [-5, 3, 6, 12, 15]
arr2 = [-12, -10, -6, -3, 4, 10]
# Concatenating the two arrays
arr3 = arr1 + arr2
# Sorting the resultant array
arr3.sort()
print("Median =", Solution(arr3))

def floorSorted(arr, low, high, x):
    if low > high:
        return -1
    if arr[low] > x:
        return -1
    if arr[high] <= x:
        return arr[high]

    mid = (low + high) // 2

    if arr[mid] == x:
        return arr[mid]

    if mid > 0 and arr[mid - 1] <= x and arr[mid] > x:
        return arr[mid - 1]

    if mid < high and arr[mid + 1] > x and arr[mid] <= x:
        return arr[mid]

    if arr[mid] > x:
        return floorSorted(arr, low, mid - 1, x)
    else:
        return floorSorted(arr, mid + 1, high, x)

arr = [1, 2, 8, 10, 12, 14, 19]
x = 5
print(floorSorted(arr, 0, len(arr) - 1, x))

def closestNumber(arr, low, high, x):
    if low > high:
        return -1
    if arr[high] < x:
        return arr[high]
    if arr[low] >= x:
        return arr[low]

    mid = (low + high) // 2
    if arr[mid] == x:
        return arr[mid]

    abs_mid = abs(arr[mid] - x)
    if mid > 0:
        abs_left = abs(arr[mid - 1] - x)
        if abs_left < abs_mid:
            return closestNumber(arr, low, mid - 1, x)

    if mid < high:
        abs_right = abs(arr[mid + 1] - x)
        if abs_right < abs_mid:
            return closestNumber(arr, mid + 1, high, x)

    return arr[mid]

arr = [2, 5, 6, 7, 8, 8, 9]
x = 9
print(closestNumber(arr, 0, len(arr) - 1, x))

def fixedPoint(arr, low, high):
    if low > high:
        return -1
    if arr[high] == high:
        return arr[high]
    if arr[low] == low:
        return arr[low]

    mid = (low + high) // 2
    if arr[mid] == mid:
        return arr[mid]

    if mid > arr[mid]:
        return fixedPoint(arr, mid + 1, high)
    else:
        return fixedPoint(arr, low, mid - 1)

arr = [9, 1, 4, 5, 2]
print(fixedPoint(arr, 0, len(arr) - 1))